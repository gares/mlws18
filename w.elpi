filter [] _ [].
filter [X|XS] P [X|YS] :- P X, !, filter XS P YS.
filter [_|XS] P YS :- filter XS P YS.

mem [X|_] X :- !.
mem [_|XS] X :- mem XS X.

if G T _ :- G, !, T.
if _ _ E :- E.

kind term type.
type app term -> term -> term.
type lam (term -> term) -> term.
type let term -> ty -> (term -> term) -> term.
type eq term -> term -> term -> term.

kind tye type.
infixr ==> 50.
infixl # 60.
type (==>) tye -> tye -> tye.
type (#) tye -> tye -> tye.

kind ty type.
type all (tye -> ty) -> ty.
type mono tye -> ty.

type one term.
type plus term.
type size term.
type xnil term.
type xcons term.
type comma term.

type booleq term.
type inteq term.
type listeq term.
type paireq term.

type integer tye.
type boolean tye.
type list tye.
type pair tye.

% constants
w one    (mono integer).
w plus   (mono (integer ==> integer ==> integer)).
w size   (all x\ mono (list # x ==> integer)).
w xnil    (all x\ mono (list # x)).
w xcons   (all x\ mono (x ==> list # x ==> list # x)).
w comma  (all x\ all y\ mono (x ==> y ==> (pair # x # y))).

eqtype integer inteq.
eqtype boolean booleq.
eqtype (list # A) (app listeq F) :- eqtype A F.
eqtype (pair # A # B) (app (app paireq FA) FB) :- eqtype A FA, eqtype B FB.

pred w i:term, o:ty.

w (app F X) (mono R) :-
  w F (mono (A ==> R)),
  w X (mono A).

w (lam F) (mono (A ==> R)) :-
  pi x\ w x (mono A) => w (F x) (mono R).

w (let F FP B) (mono TC) :-
  w F (mono FT),
  declare_constraint (overbar (mono FT) FP) W_,
  pi x\ w x FP => w (B x) (mono TC).

w (eq F LHS RHS) (mono boolean) :-
  w LHS (mono T),
  w RHS (mono T),
  % monodirectional?
  % w RHS (mono T1), if (not(T1 = T)) (type-error RHS T1 T) true,
  eqtype T F.

w X (mono T) :- w X (all Poly), specialize X (all Poly) T.

w _ (all _) :- !, fail.
w X (mono ETY) :- w X (mono TY), type-error X TY ETY.

pred specialize i:term, i:ty, o:tye.

specialize X (all F) T :- specialize X (F FRESH_) T.
specialize _ (mono T) T.
specialize X (mono TY) ETY :- type-error X TY ETY.

pred overbar i:ty, o:ty.

constraint w overbar {

rule \ (G ?- overbar T T1)
     | (generalize G T POLYT) <=> (T1 = POLYT).

rule \ (G ?- overbar T _) <=> (print "overbar" G "|-" T "failed", halt).

generalize G (mono T) ALL :-
  free-ty (mono T) [] VT,
  free-gamma G [] VG,
  filter VT (x\ not(mem VG x)) Q,
  quantify Q T ALL.

free-ty (mono X) L L1 :- free X L L1.
free-ty (all F) L L1 :- pi x\ free-ty (F x) L L1.

free-gamma [] L L.
free-gamma [w _ T|X] L L2 :- free-ty T L L1, free-gamma X L1 L2.

free (A # B) L L2 :- free A L L1, free B L1 L2.
free (A ==> B) L L2 :- free A L L1, free B L1 L2.
free (uvar X _) L L1 :- if (mem L X) (L1 = L) (L1 = [X|L]).
free _ L L.

copy-ty (mono X1) (mono X2) :- copy X1 X2.
copy-ty (all F1) (all F2) :- pi x\ copy x x => copy-ty (F1 x) (F2 x).

copy (A ==> B) (A1 ==> B1) :- copy A A1, copy B B1.
copy (A # B) (A1 # B1) :- copy A A1, copy B B1.
copy integer integer.
copy boolean boolean.
copy list list.
copy pair pair.
copy (uvar U L) (uvar U L).

quantify [] X (mono X1) :- copy X X1.
quantify [X|XS] T (all x\ T2 x) :-
  quantify XS T T1,
  pi x\ copy (uvar X _) x => copy-ty T1 (T2 x).

}

