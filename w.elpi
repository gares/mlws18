%%%%%%%%%%% datatypes %%%%%%%%%%%%%%%

% terms
kind term type.

type app term -> term -> term.
type lam (term -> term) -> term.
type let term -> ty -> (term -> term) -> term.
type eq term -> term -> term -> term.
type num int -> term.
type const string -> term.

% type expressions
kind tye type.

infixr ==> 50.
infixl # 60.

type (==>) tye -> tye -> tye.
type (#)   tye -> tye -> tye.

type integer tye.
type boolean tye.
type list tye.
type pair tye.

% types
kind ty type.

type all (tye -> ty) -> ty.
type mono tye -> ty.

%%%%%%%%%%%% w %%%%%%%%%%%%%%

pred w i:term, o:ty.

% constants
w (num _)         (mono integer).
w (const "plus")  (mono (integer ==> integer ==> integer)).
w (const "size")  (all x\ mono (list # x ==> integer)).
w (const "[]")    (all x\ mono (list # x)).
w (const "::")    (all x\ mono (x ==> list # x ==> list # x)).
w (const ",")     (all x\ all y\ mono (x ==> y ==> (pair # x # y))).

w (app F X) (mono R) :-
  w F (mono (A ==> R)),
  w X (mono A).

w (lam F) (mono (A ==> R)) :-
  pi x\ w x (mono A) => w (F x) (mono R).

w (let F PT B) (mono TB) :-
  w F (mono T),
  overbar (mono T) PT,
  pi x\ w x PT => w (B x) (mono TB).

w (eq F LHS RHS) (mono boolean) :-
  w LHS (mono T),
  w RHS (mono T),
  % monodirectional?
  % w RHS (mono T1), ( (T1 = T) ; (type-error RHS T1 T) ),
  eqtype T F.

w X (mono T) :- w X (all Poly), specialize X (all Poly) T.

w X (mono ETY) :- w X (mono TY), type-error X TY ETY.

pred specialize i:term, i:ty, o:tye.

specialize X (all F) T :- specialize X (F FRESH_) T.
specialize _ (mono T) T.
specialize X (mono TY) ETY :- type-error X TY ETY.

%%%%%%%%%%%% overbar %%%%%%%%%%%%%

pred overbar i:ty, o:ty.

overbar (mono FT) FP :-
  declare_constraint (overbar (mono FT) FP) _.

constraint w overbar {

rule \  (G ?- overbar T T1)
     |  (generalize G T POLYT)
    <=> (T1 = POLYT).

rule \ (G ?- overbar T _) <=> (print "overbar" G "|-" T "failed", halt).

generalize G (mono T) ALL :-
  free-ty (mono T) [] VT,
  free-gamma G [] VG,
  filter VT (x\ not(mem VG x)) Q,
  quantify Q T ALL.

free-ty (mono X) L L1 :- free X L L1.
free-ty (all F) L L1 :- pi x\ free-ty (F x) L L1.

free-gamma [] L L.
free-gamma [w _ T|X] L L2 :- free-ty T L L1, free-gamma X L1 L2.

free (A # B) L L2 :- free A L L1, free B L1 L2.
free (A ==> B) L L2 :- free A L L1, free B L1 L2.
free (uvar X _) L L1 :- if (mem L X) (L1 = L) (L1 = [X|L]).
free _ L L.

copy-ty (mono X1) (mono X2) :- copy X1 X2.
copy-ty (all F1) (all F2) :- pi x\ copy x x => copy-ty (F1 x) (F2 x).

copy (A ==> B) (A1 ==> B1) :- copy A A1, copy B B1.
copy (A # B) (A1 # B1) :- copy A A1, copy B B1.
copy integer integer.
copy boolean boolean.
copy list list.
copy pair pair.
copy (uvar U L) (uvar U L).

quantify [] T (mono T1) :- copy T T1.
quantify [X|XS] T (all x\ T2 x) :-
  quantify XS T T1,
  pi x\ copy (uvar X _) x => copy-ty T1 (T2 x).

}

%%%%%%%%%%%%% eqtypes %%%%%%%%%%%%%%%%

pred eqtype o:tye, o:term.

eqtype integer (const "inteq").
eqtype boolean (const "booleq").
eqtype (list # A) (app (const "listeq") F) :- eqtype A F.
eqtype (pair # A # B) (app (app (const "paireq") FA) FB) :-
  eqtype A FA, eqtype B FB.


% {{{ stdlib: mem, filter, if...

filter [] _ [].
filter [X|XS] P [X|YS] :- P X, !, filter XS P YS.
filter [_|XS] P YS :- filter XS P YS.

mem [X|_] X :- !.
mem [_|XS] X :- mem XS X.

if G T _ :- G, !, T.
if _ _ E :- E.

% }}}

% vim:set foldmethod=marker:
